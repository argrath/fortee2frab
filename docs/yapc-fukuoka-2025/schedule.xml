<?xml version="1.0" encoding="UTF-8"?>

<schedule>
  <conference>
    <title>YAPC::Fukuoka 2025</title>
    <start>2025-11-14</start>
    <end>2025-11-15</end>
    <days>2</days>
    <timeslot_duration>00:05:00</timeslot_duration>
  </conference>
  <day index="1" date="2025-11-14" start="2025-11-14T09:00:00+09:00" end="2025-11-14T19:00:00+09:00">
    <room name="Track A">
      <event id="1">
        <title>iPhone のマイナンバーカードを使った本人確認の実装</title>
        <abstract>本セッションでは、iPhone のマイナンバーカードを使った本人確認の機能について、Verifier における技術的な観点や開発経緯などをお話しします。
先日、メルカリアプリの本人確認で iPhone のマイナンバーカードが使えるようになる機能がリリースされました。
「iPhoneのマイナンバーカード」は、 iPhone （Apple ウォレット） に入れて利用できるマイナンバーカードであり、2025 年 6 月 24 日にデジタル庁および Apple によってリリースされた新しい仕組みです。本機能は、Verify With Wallet API 経由で Apple ウォレットに登録されたマイナンバーカードに含まれる情報を取得および検証することで実現しています。
ここでは、Verify with Wallet API 経由で取得したデータを扱う Verifier の観点で、実際にサービスに導入する際に考慮したポイントを技術的な面などから共有できればと思います。</abstract>
        <date>2025-11-14T09:45:00%:z</date>
        <start>09:45</start>
        <duration>00:20:00</duration>
        <slug>d4d17d8d-e69b-43e0-8d0b-51d3f9570627</slug>
        <url>https://fortee.jp/yapc-fukuoka-2025/proposal/d4d17d8d-e69b-43e0-8d0b-51d3f9570627</url>
        <persons>
          <person> kgoro kg0r0 </person>
        </persons>
      </event>
      <event id="2">
        <title>「正規表現をつくる」をつくる</title>
        <abstract>正規表現はPerlや多くの言語で重要な機能です。
しかし、正規表現は独特の文法から、自分の手で書くのは煩わしいです。
生成AIに書かせることもできますが、本当に期待しているものになっているのかという保証がありませんし、ReDoSなどの脆弱性を生んでしまう可能性もあります。
「正規表現をつくる」プログラム
そこで、「マッチしてほしい文字列」と「マッチしてほしくない文字列」を与えたら自動で、*や+を使ったいい感じの正規表現を作ってくれるプログラムがあったら便利だと思いませんか？
今回は、そういった「正規表現をつくる」プログラムについて話します。
オートマトンと正規表現のはざまで
「正規表現をつくる」プログラムといえば、PerlにはRegexp::Assembleがあります。
ですが、Regexp::Assembleでは単にマッチしてほしい文字列を|でつないだ正規表現のようなものが出てくるだけで、*や+を使った期待する正規表現にはなりません。
期待する正規表現についてはオートマトンを使うことで定義できます。
一方、オートマトンから人間の読みやすい正規表現を得ることは簡単ではありません。
この問題の解決ために、SATソルバなどを使って解決を試みます。
むすびに
この発表では、次のような内容を話します。

「正規表現をつくる」問題について

いい感じの正規表現とは何か？

オートマトンの場合の解決方法

受動的オートマトン学習
RPNIアルゴリズム

正規表現として求めるには？

正規表現への変換の困難さ
SATソルバを使った探索


「正規表現をつくる」問題を、理論的な方法を用いながらも現実的に対処していくトークにご期待ください。</abstract>
        <date>2025-11-14T10:20:00%:z</date>
        <start>10:20</start>
        <duration>00:20:00</duration>
        <slug>8788e20c-bca5-4ff8-8c46-58673415f4f3</slug>
        <url>https://fortee.jp/yapc-fukuoka-2025/proposal/8788e20c-bca5-4ff8-8c46-58673415f4f3</url>
        <persons>
          <person> makenowjust make_now_just </person>
        </persons>
      </event>
      <event id="3">
        <title>「データ無い！腹立つ！推測する！」から「データ無い！腹立つ！データを作る」へ ― ゼロからデータを作り、チームで育てられるようにするまで</title>
        <abstract>話者が所属する組織ではプリペイドカードを用いた決済機能とそれに付随した家計簿アプリを開発しているのですが、そこでは日々膨大な量の「名前」と格闘しています。カードの決済店舗名、家計簿の支出名、レシートからの店舗名や費目名などなど……これら名前が各々何であるのかを機械が理解できるようにするにはどうすれば良いでしょうか。
例えば「セブンイレブン」という名前を見た時、人間はそれが「コンビニ」の名前であることを一目で理解できますが、未学習の計算機にこれをやらせるのは困難です。ではどうするかというとパッと思いつくのは計算機に推論させるという方法があります。昨今の大規模言語モデルであれば例に挙げたようなタスクはこなせる可能性がある一方、現状ではコストが高くなりがちという問題もあります。そもそも人間に判断が付かないものは機械にとっても難しいものです。仮に「たんぽぽ」という店舗名を見た時、これがどんな種類の店であるかを自信を持って回答できるでしょうか？　人が見ても判然としないものを機械に推論させても有意義なものが出てくるかというと難しいものがあります。
我々はこうした課題を解決するためにマスターデータ（辞書）を地道に作っています。本トークでは自然言語処理の理論・手法を要するものを、プロダクト作りの現場においてどうシステムや良い体験に適用していくかという実践的な話題を取り上げます。主に取り上げる予定の話題を紙幅の都合上以下に箇条書きにします:

LLM時代ではその知識の源泉となるデータは益々重要
推論せずに結果が得られるならば推論する必要は無い
何の解決を目的としてデータを作るか
データが無いところからどう作りはじめると良いのか（一定の根性の話）
どのように作ったデータを育てるか
作ったデータを有効に使う方法
データを作り、育て、有効活用できるチームをどう構築するか
</abstract>
        <date>2025-11-14T12:55:00%:z</date>
        <start>12:55</start>
        <duration>00:40:00</duration>
        <slug>faef2cbb-9a07-4838-a67e-f8ce3615158e</slug>
        <url>https://fortee.jp/yapc-fukuoka-2025/proposal/faef2cbb-9a07-4838-a67e-f8ce3615158e</url>
        <persons>
          <person> moznion moznion </person>
        </persons>
      </event>
      <event id="4">
        <title>大規模OSSに一人で立ち向かうには</title>
        <abstract>私は2024年の2月からWebKit（実際にはその中のJavaScript処理系であるJavaScriptCore）への貢献を開始し、1年後の2025年2月にレビュワーという最も強い権限を持つメンバーの一人になりました。
そして、2025年8月にはWebKitへの貢献が評価され、それに関連する職を手にいれることができました。
私はこれまで基本的に一人でWebKitへの貢献を行ってきました。
周りに質問できる人が全くいない中、コードベースへの理解はもちろん、独自の開発文化なども身につけながら、コミュニティからの信頼を得られるように努力してきました。
その中で「大規模なOSSに一人で立ち向かう」ためのアプローチが少しずつ見えてきました。
この発表では、WebKitのような大規模かつ技術的に複雑で歴史の長いOSSプロジェクトに一人で立ち向かい、技術的な理解を身につけながらコミュニティからある程度認められるようになるための方法について、なるべく再現性のあるアプローチについてお話しします。</abstract>
        <date>2025-11-14T13:50:00%:z</date>
        <start>13:50</start>
        <duration>00:40:00</duration>
        <slug>0d4c761a-df5b-46b9-83ef-66bea4f87fa3</slug>
        <url>https://fortee.jp/yapc-fukuoka-2025/proposal/0d4c761a-df5b-46b9-83ef-66bea4f87fa3</url>
        <persons>
          <person> Sosuke Suzuki __sosukesuzuki </person>
        </persons>
      </event>
      <event id="5">
        <title>今、MySQLのバックアップを作り直すとしたら何がどう良いのかを考える旅</title>
        <abstract>
とある デジタル庁におけるガバメントクラウド整備のためのクラウドサービスの提供（令和5年度募集） にはこんな調達仕様書がついています。

DBのバックアップを差分で取得できること。取得したバックアップはいつでもDBの復元に使用できること。復元時は別のサイズを選択できること。
DBのバックアップは、一定期間（例：5分）以前のどの時点にでも戻せるかたちで（Point In Timer Restore）取得できること。
DBのバックアップは、予め設定したタイミング、周期、世代で自動的に定期実行できること。
DBのバックアップイメージは、CSPの中であれば、別のシステム、別のネットワーク、別の環境からも利用できること。


RDBMS as a Serviceでは当たり前に提供されてきたこの機能を、もし自分たちで提供しないといけないとしたら、今この2025年ではどんなツールを使うのが良さそうなのか。

mysqldump ..?
Percona XtraBackupってどうなったのだろう？
MySQL Shellでもバックアップは取れるらしいが本当に使えるの？
Cloneプラグインでリモートバックアップが取れるって本当？
5分以前のどの時点でも戻せるかたちで取得ってどうする？
試行錯誤してたどり着いたバックアップの取り方をお話しします。
</abstract>
        <date>2025-11-14T14:45:00%:z</date>
        <start>14:45</start>
        <duration>00:20:00</duration>
        <slug>1ee39cf1-a581-450d-8692-a9a9f7f39b7f</slug>
        <url>https://fortee.jp/yapc-fukuoka-2025/proposal/1ee39cf1-a581-450d-8692-a9a9f7f39b7f</url>
        <persons>
          <person> yoku0825 yoku0825 </person>
        </persons>
      </event>
      <event id="6">
        <title>Perl ブートキャンプ</title>
        <abstract>
いいか、みんな
　　　　　　　　(ﾟдﾟ )
　　　　　　　　(|　y |)
ハッシュリファレンスと package では手続き型プログラミングしかできないが
　　　　　 {}　  ( ﾟдﾟ)　package
　　　　　　　＼／|　y |＼／
　　　　二つ合わさればOOPとなる
　　　　　　　　( ﾟдﾟ)　 bless
　　　　　　　　(＼／＼／


Perl を初めて触る方を対象とした、1 時間の速習ワークショップです。対象は他の言語に慣れている Web エンジニアを想定しています。
Perl における OOP の歴史や、強力な正規表現、特殊変数の世界など、現代から見る Perl の奇妙さを体験しつつ、現代的な Perl プログラミングまで駆け抜けます。
文法の細部よりも、Perl 独特の仕組みと速習のポイントを凝縮し、短時間で「Perl を読める」「ここに戻ってきたら分かる」という感触を得られる構成です。
はてなサマーインターンシップで使ってきた はてな教科書 を下敷きにしています。</abstract>
        <date>2025-11-14T15:30:00%:z</date>
        <start>15:30</start>
        <duration>00:60:00</duration>
        <slug>6e85f910-a1fa-4755-ac34-1852397be1ca</slug>
        <url>https://fortee.jp/yapc-fukuoka-2025/proposal/6e85f910-a1fa-4755-ac34-1852397be1ca</url>
        <persons>
          <person> Takafumi ONAKA onk </person>
        </persons>
      </event>
      <event id="7">
        <title>クレジットカードの不正を防止する技術</title>
        <abstract>皆さんもクレジットカードを使った際に、身に覚えのない決済が来て、不正に利用されてしまっていたという経験があるのではないでしょうか？
不正といっても、クレジットマスターアタック、スキミングといった外部からの攻撃、カード所有者による悪意のある決済など、多岐に渡り不正決済は年々増加しています。
本トークではカード事業者が不正を防止するために日々行っている攻撃の検知、分析、対策、評価といった一連の運用やそれらを支えるシステムの開発をどのように行っているかを技術的な文脈を元にお話しします。
具体的には以下のような内容をお話しする予定です。

カード決済における代表的な攻撃とそのパターン検知、および対策をどうやっているか
不正決済を検知し防止、抑制するためのシステムをどのように構築しているか
不正対策を行っているチームの日常、どのようなKPIを設定して攻撃の予防や改善を行なっているか

本トークを聞くことで、皆さんのカード決済が安心に行えている一旦が垣間見れるかもしれません。</abstract>
        <date>2025-11-14T17:40:00%:z</date>
        <start>17:40</start>
        <duration>00:20:00</duration>
        <slug>055b33be-0474-4c30-91ca-99985adbc080</slug>
        <url>https://fortee.jp/yapc-fukuoka-2025/proposal/055b33be-0474-4c30-91ca-99985adbc080</url>
        <persons>
          <person> Yuta Horii yutadayo </person>
        </persons>
      </event>
    </room>
    <room name="Track B">
      <event id="8">
        <title>なぜ強調表示できず ** が表示されるのか — Perlで始まったMarkdownの歴史と日本語文書における課題</title>
        <abstract>Markdown記法で記述された文書は、GitHubやQiita、そしてこのforteeなど我々がよく利用するサービスで数多く見つけることができます。さらに最近では、AIからのテキスト出力もMarkdown形式であることが多く、馴染み深い方も多いでしょう。
しかしAIからの出力の中には、たまに強調表示に失敗し、 「おや？」と思うことってありませんか？
我々は単にアスタリスクで囲われた内部を強調して欲しいだけなのに、どうしてそんな一見シンプルな処理に失敗することがあるのでしょうか。
この身近な問い（Q）を解くためには、Markdownの原点に遡らなければなりません。2004年に公開された最初のMarkdownは、一つのPerlスクリプトでした。本トークは、強調表示の失敗という身近な問題をきっかけとして、この"旧"Markdown（Markdown.pl）まで遡ります。
まず、なぜ単純に見える強調表示に失敗しうるのか、Markdown記法の標準化プロジェクトであるCommonMarkの強調ルールとともに解説します。次に、原点であるMarkdown.pl、Markdownの普及と相互運用性という課題、CommonMarkの始まりと強調表示の仕様策定経緯に触れ、この問題に至るまでの歴史を紐解きます。さらに、現状のコミュニティでの議論と、正しく強調表示するために我々が採りうる手段についても共有します。
加えて、日本語の改行（soft line break）問題やルビ表記といった、日本語固有の他の課題にも焦点を当てる予定です。
このトークを通じて、普段何気なく使っているMarkdownの現在地を、その歴史から日本語という観点で再確認し、より快適な日本語ドキュメンテーションへの道筋を皆さんと共有します。</abstract>
        <date>2025-11-14T09:45:00%:z</date>
        <start>09:45</start>
        <duration>00:20:00</duration>
        <slug>d277b1c6-47da-4fea-a9f6-372e46965448</slug>
        <url>https://fortee.jp/yapc-fukuoka-2025/proposal/d277b1c6-47da-4fea-a9f6-372e46965448</url>
        <persons>
          <person> hkws __tortoise </person>
        </persons>
      </event>
      <event id="9">
        <title>k1LoW/deckを急激に(100倍以上)高速化する方法</title>
        <abstract>deckはk1LoWさんが開発された、MarkdownからGoogleスライドを継続的に作成するための非常に優れたOSSであり、Goで書かれています。
筆者は、7月からこのツールを使い始めると同時に、その後の数ヶ月で多くの改善提案及びpull requestを行いました。コード行数にすると1万行以上に及びます。最終的にはコア開発者にも加えてもらいました。
deckを使いやすくするための数多くの変更をおこないましたが、中でも特筆すべきはそのパフォーマンス向上でしょう。10分以上かかっていたスライド生成が10秒以内で完了するようになったケースもあり、実に100倍以上の高速化を達成しています。
これらは、良く言われる「計測」で達成できた部分もありますが、実際にはTidy First的に仕様やコードの整理整頓をする中で自然と速くなったもの、その過程で高速化のアイデアが湧いて実現できた物も少なくありません。その過程で作者のk1LoWさんとも議論を重ねることもありました。それらの段階的な改善が、結果的に劇的なパフォーマンス向上に繋がったのです。
本トークでは、実際のdeckの高速化の旅路を具体的事例にとり、OSSやソフトウェア開発におけるパフォーマンスチューニングの秘訣についてお話します。</abstract>
        <date>2025-11-14T12:00:00%:z</date>
        <start>12:00</start>
        <duration>00:40:00</duration>
        <slug>15e6392e-8647-4b4e-856a-6067e82a8d3a</slug>
        <url>https://fortee.jp/yapc-fukuoka-2025/proposal/15e6392e-8647-4b4e-856a-6067e82a8d3a</url>
        <persons>
          <person> 松木 雅幸 / Songmu songmu </person>
        </persons>
      </event>
      <event id="10">
        <title>2025年秋のPerl</title>
        <abstract>今年はPerl 5.42のリリースが遅れたこともあり、次期バージョンについての情報はまだほとんどありませんが、現在の安定版である5.42の情報を中心に最近のPerl界隈のニュースなどを紹介します。</abstract>
        <date>2025-11-14T12:55:00%:z</date>
        <start>12:55</start>
        <duration>00:40:00</duration>
        <slug>ec390ea3-d593-48f7-b023-55e2df1fc250</slug>
        <url>https://fortee.jp/yapc-fukuoka-2025/proposal/ec390ea3-d593-48f7-b023-55e2df1fc250</url>
        <persons>
          <person> charsbar charsbar </person>
        </persons>
      </event>
      <event id="11">
        <title>Quine for Everyone</title>
        <abstract>Quineというのは自分自身を出力するプログラムのことで，プログラミングによるアートです。Web上には様々なQuineが公開され，その芸術を競っています。皆さんはそういったQuineを見てQuineとは難しいものだと思われているかもしれません。しかし恐れることはありません。Quineは皆さんと共にあります。ライブコーディング形式でやりますので皆さんもノートPCを持参して一緒に書いてみてください！
この話はもともとYAPC::Kyoto 2020で話す予定でしたが、COVID-19で延期になってしまい、結局Rebootできずお蔵入りになったものです。今回のYAPCのテーマは「きゅう」ということでこの機会にQ(uine)のお話を復活させたいと思います。
普段はPythonやRubyを書いているのですが、Quineは言語はあまり関係ないのでYAPCですしPerlでお話します。</abstract>
        <date>2025-11-14T13:50:00%:z</date>
        <start>13:50</start>
        <duration>00:40:00</duration>
        <slug>28b3a042-a2e9-4866-bd76-3be08608c7b2</slug>
        <url>https://fortee.jp/yapc-fukuoka-2025/proposal/28b3a042-a2e9-4866-bd76-3be08608c7b2</url>
        <persons>
          <person> 大林 _ohai </person>
        </persons>
      </event>
      <event id="12">
        <title>「バイブス静的解析」でレガシーコードを分析・改善しよう</title>
        <abstract>大規模なプロダクトでは、lintや、use漏れチェック、使ってないファイルの検出といった、静的解析を伴う開発支援ツールが重宝されます。
しかし、存在するすべての記法を扱う必要のある汎用ツールでは、どうしても実行時間が伸びてしまったり、プロジェクト固有のかゆいところに手が届きにくかったり、といった課題がつきものです。
発表者が携わる、開発期間約10年・数十万行規模のリポジトリでは、近年注目されている"vibe coding"の考えを下敷きに、プロジェクト専用の軽量なツールを開発して、開発支援に活用しています。
本発表では、プロジェクト固有の静的解析ツールをAIとともに開発し、レガシーコード改善に活用する「バイブス静的解析」を提唱します。
静的解析を用いたツールのこれまで

PPI, PPRを使った汎用ツールのおさらい
汎用的がゆえに、いかなるソースコードも正しく解釈しなければならない宿命
ツールの実行時間増加への利用者側の工夫

バイブス静的解析のアプローチ

プロジェクトに合わせた専用の静的解析ツールを「バイブス」重視、すなわち、勢いで開発する
完璧を目指さず、コードベース上で必要な表現だけに対応する
AIの力を借りて、誰でも保守でき、壊れても機能開発の片手間に短時間で直せるものを目指す

ゴール

「バイブス静的解析」の考えを使って、新たなツールを勢い重視で開発できるようになる
お手元のリポジトリから、数秒以内にuse漏れや不要ファイルといったエラーを検出できるようになる
</abstract>
        <date>2025-11-14T14:45:00%:z</date>
        <start>14:45</start>
        <duration>00:20:00</duration>
        <slug>c4e33dea-0860-488d-ae37-db45c5c4acda</slug>
        <url>https://fortee.jp/yapc-fukuoka-2025/proposal/c4e33dea-0860-488d-ae37-db45c5c4acda</url>
        <persons>
          <person> hitode909 hitode909 </person>
        </persons>
      </event>
      <event id="13">
        <title>Agentに至る道 〜なぜLLMは自動でコードを書けるようになったのか〜</title>
        <abstract>2025年はコーディングエージェントによる自動コーディングが、仕事の現場でも浸透し始めた年であると言えます。
ところでChatGPTが出た2022年末を思い出してください。確かに受け答えは出来るし、このようなコードを書いてという指示を出すと確かにコード片は出せましたが、それを仕事の中でメインで使ったり、ましてや自動で指示をしたら勝手に書いてくことは想像できませんでした。
もちろんLLM自体の進化もありますが、LLMをどのように使えば効果的にタスクを実行できるか、つまり"エージェント"である部分の進化がコーディングする機械としての実用性を向上させたと私は考えます。
このセッションの前半では「エージェントとは何か」をその概念のもととなった論文などをもとに説明します。具体的には以下のような項目です。

ReAct
Function Calling

このセッションの後半では、ReActループおよび、Function Callingを備えたコーディングエージェントのライブコーディングを行います。使用する言語はPerlですが、出来るだけ他言語の方でも分かりやすいように解説を多めに述べます。
このセッションに参加した方は以下のものが得られます。

コーディングエージェントに代表されるAIエージェントの概念の習得

LLMとエージェントシステムの境界線の認識

コーディングエージェントを作成する際に考慮すべきこと

コンテキストサイズに収まるファイル読み込み
Function Calling
ReActループ

「コードを書く」とは何なのかを洞察する機会

コーディングとはコードをただ書くだけではなく周囲のコードを読んだり、ドキュメントを読むことで成り立っている行為

</abstract>
        <date>2025-11-14T15:30:00%:z</date>
        <start>15:30</start>
        <duration>00:60:00</duration>
        <slug>fb1e7046-74ea-4856-9311-7b7cd62a6018</slug>
        <url>https://fortee.jp/yapc-fukuoka-2025/proposal/fb1e7046-74ea-4856-9311-7b7cd62a6018</url>
        <persons>
          <person> macopy mackee_w </person>
        </persons>
      </event>
      <event id="14">
        <title>Perl1.0をもう一度、あるいはRubyによる旧Perlの再実装</title>
        <abstract>現在はPerl5.42となったPerlですが、1994年から31年間ずっとPerlはPerl5です。
そのPerlの「きゅう」バージョン、すなわちPerl5前史に目を向けると、1987年にラリー・ウォールによって公開されたPerl1.0が最初のバージョンであることがわかります。
ところで私は今年からRubyの会社に転職しました。Perlで育ってきた私がどのようにRubyを勉強していけばいいのか悩みました。そこで思ったのです。最もかける言語であるPerlをRubyで書いたらすべてが解決するのではないかと———。
このトークではPerl1.0のソースコードを紐解き、Rubyインタプリタによって再実装していきます。
【多分こういう内容】

Perl1.0のソースコード徹底解説
AIを使って古いコードを読むテクニック
StringScanner/Racc入門
ASTのVM化
</abstract>
        <date>2025-11-14T16:45:00%:z</date>
        <start>16:45</start>
        <duration>00:40:00</duration>
        <slug>893a225a-78cd-4549-8b6f-29ba138807da</slug>
        <url>https://fortee.jp/yapc-fukuoka-2025/proposal/893a225a-78cd-4549-8b6f-29ba138807da</url>
        <persons>
          <person> 八雲アナグラ AnaTofuZ </person>
        </persons>
      </event>
      <event id="15">
        <title>頑なに再代入しない！</title>
        <abstract>コードを読んでいると、この変数はどこで定義され、どこで値が設定されたのか？を確認することがしばしばあります。
再代入が多いとどのタイミングで値が変更されるのか？を確認するコストが発生するので、私はめんどうだと思ってしまいます。
また、再代入がないほうがメンテナンス性が高いと信じています。なぜならば、すべてが再代入なし（= すべてが定数）の方がバグが生まれにくいはずだからです。
（いわゆる関数型プログラミング、というやつです。）
と、いうことで私は基本的に再代入をしないコードを書くように心がけています。
（もちろん、それによるデメリットがあるのも承知でそのようにしています。）
私が始めたOSSではありませんが、現在は9割方私が書いたコードになっているnode-lambda ( https://github.com/motdotla/node-lambda ) （JavaScriptです）を例に、頑なに再代入をしない（関数型プログラミング）を実践した例を紹介します。
（これまではデメリットについて、厳密に検証したことがなかったのですが、改めて検証してまとめてデメリットについても発表します。）
大規模開発の参考になること間違いなし！</abstract>
        <date>2025-11-14T17:40:00%:z</date>
        <start>17:40</start>
        <duration>00:20:00</duration>
        <slug>3cd5d074-2b62-4d25-95e2-3ec5b2b69a48</slug>
        <url>https://fortee.jp/yapc-fukuoka-2025/proposal/3cd5d074-2b62-4d25-95e2-3ec5b2b69a48</url>
        <persons>
          <person> abetomo </person>
        </persons>
      </event>
    </room>
    <room name="Track C">
      <event id="16">
        <title>HTTP Message Signatures ― HTTPクライアントの身の証を立てる</title>
        <abstract>概要
自由にアクセスできるHTTPサーバに対して、クライアントが自らの身の証を立てるのは難しいものです。IPアドレスは完全ではないですし、User-Agentヘッダはなりすましが容易です。
この問題を解決するため、10年以上の議論を経て去年勧告されたのがHTTP Message Signatures(RFC9421)です。
このセッションでは、本仕様をPerlで実装した経験を基に、実例を交えつつ本仕様を概説します。
また、本仕様の理解に必要で、今後生まれるHTTP仕様の理解の前提になることがが想定される、Structured Field Values for HTTP(RFC 9651)についても触れます。
想定聴衆

AIボット、クロウラーなど、機械的に不特定多数のサーバにアクセスするクライアントを作成したい方
逆に、このようなクライアントからのアクセスを識別したいサーバ管理者の方
</abstract>
        <date>2025-11-14T09:45:00%:z</date>
        <start>09:45</start>
        <duration>00:20:00</duration>
        <slug>256a2222-e9f2-45ba-820d-1698033c210c</slug>
        <url>https://fortee.jp/yapc-fukuoka-2025/proposal/256a2222-e9f2-45ba-820d-1698033c210c</url>
        <persons>
          <person> 白方 健太郎 argrath </person>
        </persons>
      </event>
      <event id="17">
        <title>Introducing RFC9111</title>
        <abstract>現在HTTP Cacheに関するRFCは7234...ではありません。
2022年に改訂され、RFC「9」111 HTTP CachingとしてInternet Standardになっています。
本発表ではRFC9111、特に共有キャッシュについて見ていきます。
プロキシサーバのアップストリームに位置するWebアプリケーションとしてどうすればキャッシュをしてくれるのか、もしくは拒否できるのか。
理解すれば、実装にはよりますが少なくともRFCに沿った議論ができるようになります。
発表者はRFC9111に沿ったキャッシュミドルウェアを実装しています。
https://github.com/2manymws/rc
この実装経験に基づいた紹介をします。
（なお、2025年8月現在rfc9111で検索して出てくるのは我々のリポジトリを含めて5つ https://github.com/search?q=rfc9111&amp;type=repositories ）
この機会に「RFC9111完全に理解した」になりましょう！</abstract>
        <date>2025-11-14T10:20:00%:z</date>
        <start>10:20</start>
        <duration>00:20:00</duration>
        <slug>8b6306dd-fb64-4f5d-afc7-f98a20925c7b</slug>
        <url>https://fortee.jp/yapc-fukuoka-2025/proposal/8b6306dd-fb64-4f5d-afc7-f98a20925c7b</url>
        <persons>
          <person> 小山健一郎 k1LoW </person>
        </persons>
      </event>
      <event id="18">
        <title>なぜインフラコードのモジュール化は難しいのか - アプリケーションコードとの本質的な違いから考える</title>
        <abstract>YAPC::Japanがリブートした2016年当時、Terraformはまだv0.7の段階で、インポート、Data Sources、ステート管理CLIといった機能が実装されました。
あれから9年、Terraformはv1.12となり、ツールとして成熟しました。モジュール機能も2014年のv0.3から実装されています。
しかし、Terraformでモジュール化を進めると、様々な「辛さ」に直面し、時に「窮」地に陥ります。大量のパラメータ、どんなリソースが作られるか分からない不安、細部を制御できないもどかしさ、モジュールの多層化による見通しの悪さ——これらは単なる実装の問題ではなく、インフラコードとアプリケーションコードの本質的な違いから生まれる必然的な課題です。
なぜこのような辛さが生まれるのでしょうか？本セッションでは、両者の根本的な違いである「記述の視点」から出発し、そこから必然的に生まれるモジュール化アプローチの違いを紐解いていきます。
根本的な違い

記述の視点：状態を記述する vs 処理を記述する

この違いから生まれるモジュール化の特徴

抽象化の目的：構成のテンプレート化 vs 処理のカプセル化
再利用の考え方：ホワイトボックス的利用 vs ブラックボックス的利用
設計の難しさ：抽象化と可視性の板挟み vs 抽象化に専念できる
階層化の影響：モジュールの多層化による透明性の低下 vs 階層化による整理

これらの違いを理解することで、インフラコードのモジュール化が難しい本質的な理由と、その難しさとどう向き合うべきかを考察します。
想定する聴衆

インフラエンジニア、SRE
インフラにも関わるアプリケーション開発者
</abstract>
        <date>2025-11-14T12:00:00%:z</date>
        <start>12:00</start>
        <duration>00:40:00</duration>
        <slug>edd5ad15-3152-4f2c-9df1-6daad7944327</slug>
        <url>https://fortee.jp/yapc-fukuoka-2025/proposal/edd5ad15-3152-4f2c-9df1-6daad7944327</url>
        <persons>
          <person> 宮下 剛輔 gosukenator </person>
        </persons>
      </event>
      <event id="19">
        <title>Amazon ECSデプロイツールecspressoの開発を支える「正しい抽象化」の探求</title>
        <abstract>私が開発しているAmazon ECSデプロイツール「ecspresso」は、前回福岡で開催されたYAPC::Fukuoka 2017の半年後に誕生しました。8年間にわたって開発を継続した結果、GitHub Stars 950+を獲得し、現在でも国内企業で広く利用されています。本セッションでは、長年個人で開発しているecspressoがECSの新機能追加に急速に追従し続けられる理由と、その設計を探求します。
ecspressoは「AWS SDKをほぼそのまま使う薄いラッパー設計」を採用しています。これは実は怠惰ゆえだったのですが、結果的には新機能に即日対応できる、急速な追従性を実現する要因となりました。実際にEFSマウントやBlue/Greenデプロイメントへの追従は、コード数行の変更で実現されています。一方、TerraformやAWS Copilotなどの他のIaCツールは、独自DSLや抽象度の高いインターフェースを採用し、異なる設計上のトレードオフを選択しています。
2025年7月に開催された「設計ナイト2025」での発表 https://speakerdeck.com/fujiwara3/sekkeinight2025
では、ecspressoの設計思想に至る道のりを振り返りました。そこでは、組織構造と責任分界点がツールの設計に与える影響について語りました。
今回の発表はその続編です。設計思想を実装に落とし込む過程と具体的なコードやエピソードを交えながら、「正しい抽象化」を探求します。「抽象化しない勇気」「制約が生む創造性」「適材適所の設計」など、8年間のメンテナンスから得られた実践的な知見を共有します。</abstract>
        <date>2025-11-14T12:55:00%:z</date>
        <start>12:55</start>
        <duration>00:40:00</duration>
        <slug>0b964339-fb1d-463a-a99f-74b91f108e44</slug>
        <url>https://fortee.jp/yapc-fukuoka-2025/proposal/0b964339-fb1d-463a-a99f-74b91f108e44</url>
        <persons>
          <person> 藤原俊一郎 fujiwara </person>
        </persons>
      </event>
      <event id="20">
        <title>なぜThrottleではなくDebounceだったのか？ 700並列リクエストと戦うサーバーサイド実装のすべて</title>
        <abstract>ある日突然、あるサービスに急（きゅう）なスパイクアクセスがやってきました。その数、700並列。サーバーは悲鳴をあげ、DBは沈黙しました。
高負荷対策の定石といえば、キュー (Job Queue) を思い浮かべるかもしれません。しかし、安易にジョブを Queue に入れるだけでは、結局700並列の重い処理が非同期に実行されるだけ。そこから、いかにして本当に必要な処理だけを「間引く」かが本当の課題でした。
こうした処理の間引きには、一般的にスロットル (Throttle) が用いられます。では、なぜその一般的な手法である Throttle ではダメだったのか？ 本トークでは、似て非なる Throttle とデバウンス (Debounce) の違いを解説しつつ、サーバーサイドでの Debounce 実装に至るまでの道のりを赤裸々にお話しします。
単純な実装だったv1から、その改良版であるv2ですら対応できなかった現実の複雑なユースケース、そして最終的にたどり着いた動的な遅延制御ロジック(v3)まで――3度の再実装の過程を、v1からv3へと進化していく実際のコードを追いながら、その思考と共に解説します。
この実例で語る負荷制御の勘所と設計思想が、あなたの武器庫に加わる新たな一つになれば幸いです。</abstract>
        <date>2025-11-14T13:50:00%:z</date>
        <start>13:50</start>
        <duration>00:40:00</duration>
        <slug>0b931b36-e916-4461-bbf1-886419280759</slug>
        <url>https://fortee.jp/yapc-fukuoka-2025/proposal/0b931b36-e916-4461-bbf1-886419280759</url>
        <persons>
          <person> Yoshiori yoshiori </person>
        </persons>
      </event>
      <event id="21">
        <title>Learning Scalable DNS Resolvers from Hyper-Scalers</title>
        <abstract>DNS Full ResolverはIDCやISPなど多くの環境で構築/運用されています。
Office NetworkやIDC内での利用ではあまり問題にはなりませんが、ISPやさらに大きいスケールでの運用では問題が発生する事があります。
このセッションでは、小規模から中規模でどのような運用パターンが実施されているのかを解説し、また、大規模な環境ではどのようにDNS Full Resolverをスケーリングさせているのかについてまず解説します。
その後、さらに巨大なPublic DNSのようなHyper-Scalerは巨大なDNS Full Resolverをどのように構築しているのかを、PublicなDocumentから分かる範囲で調査した内容を解説します。
また、Hyper-Scalerが実際に行って居るDNS Full Resolverをどのように実装するのかの簡単なPoCを実装し解説します。
DNSという長く開発、運用されているシステムを調査/開発する楽しさを共有します。</abstract>
        <date>2025-11-14T14:45:00%:z</date>
        <start>14:45</start>
        <duration>00:20:00</duration>
        <slug>67512650-017e-4fea-ac00-23833e4221fc</slug>
        <url>https://fortee.jp/yapc-fukuoka-2025/proposal/67512650-017e-4fea-ac00-23833e4221fc</url>
        <persons>
          <person> 川上けんと Kawakami_Kento </person>
        </persons>
      </event>
      <event id="22">
        <title>セキュリティを 「ふつう」にやっていく 技術、体制、文化の追求</title>
        <abstract>およそ事業運営では「汲」めども尽きぬ問題・課題に立ち向かわなければなりませんが、セキュリティにおいても同様でしょう。
GMOペパボのセキュリティ対策室は、過去のインシデント再発防止を契機として設立された組織であり、私 @hiboma は当初から技術職上位等級としてコミットしてきました。 「急」な対応を要するセキュリティイベントは尽きることがありません。脆弱性の対応、不審なアラート通知、脅威の検出、障害・ヒヤリハット・セキュリティインシデントの発生 ... と何かが起きる度に「窮」する思いで立ち向かっています。
実施してきた対策を上げればきりがなく、基盤技術の導入、組織体制・規定・ガイドライン・プロセスの整備、インシデント対応の支援自動化、シフトレフト・DevSecOps の実践、Web セキュリティ・クラウドセキュリティ・エンドポイントセキュリティ, Security for AI / AI for Security ... 未だ課題が山積みです。
ある時は 「やっていき」（リーダーシップ）を発揮して、また、ある時は同僚に「のっていき」（フォロワーシップ）しながら、セキュリティの実践を 「ふつう」にやっていく 技術・体制・文化の追求についてトークします。</abstract>
        <date>2025-11-14T17:05:00%:z</date>
        <start>17:05</start>
        <duration>00:20:00</duration>
        <slug>efaabea1-ed02-444b-9798-2809ce67db1d</slug>
        <url>https://fortee.jp/yapc-fukuoka-2025/proposal/efaabea1-ed02-444b-9798-2809ce67db1d</url>
        <persons>
          <person> 伊藤洋也 hiboma </person>
        </persons>
      </event>
      <event id="23">
        <title>ARA へ捧げる鎮魂歌（レクイエム）</title>
        <abstract>ここ数年、来るべきクッキーレス時代に備え、デジタルマーケティング分野に関わるエンジニア達は人知れず戦ってきました。現役の広告エンジニアである筆者もその最前線に身を投じた一人です。しかし、 2025 年 4 月、 Google は 3rd party cookie の廃止を事実上断念し、その壮大な挑戦は突如として大きな転換点を迎えます。
このトークは、その激動の渦中に生まれた Attribution Reporting API (ARA) という技術へ捧げる、筆者からの鎮魂歌です。
ARAは、プライバシーを守るという理想が生んだ、あまりにも複雑で難解な人工遺物です。しかし、その複雑さの奥には、最先端の Google エンジニア達による知恵と格闘の跡が刻まれています。このトークでは、2024 年 1 月のプロジェクト発足以来 1 年以上 Attribution Reporting API (ARA) の実装に携わった筆者が、 ARA の仕様を読み解くために必要な知識を短時間で効率よく収集することを目標に、以下のキーワードを解説します。

Attribution Reporting API (ARA)
registration
attribution source/trigger
source type event/navigation
event-level/aggregatable&amp;summary report
Publishser / Advertiser / Adtech / Browser
contribution budget
ノイズと差分プライバシー
Aggregation Service と TEE
</abstract>
        <date>2025-11-14T17:40:00%:z</date>
        <start>17:40</start>
        <duration>00:20:00</duration>
        <slug>cb6bd9d9-69cd-41fd-ba41-d3adb1ae5dc1</slug>
        <url>https://fortee.jp/yapc-fukuoka-2025/proposal/cb6bd9d9-69cd-41fd-ba41-d3adb1ae5dc1</url>
        <persons>
          <person> hiratara hiratara </person>
        </persons>
      </event>
    </room>
  </day>
  <day index="2" date="2025-11-15" start="2025-11-15T09:00:00+09:00" end="2025-11-15T19:00:00+09:00">
    <room name="Track A">
      <event id="24">
        <title>OSS開発者の憂鬱</title>
        <abstract>「OSS」ってキラキラして見えるかもしれないけど、憂鬱になることがたくさんある。これまで愚痴を表に出すことはしなかったけど、このトークではあえてそれをさせてくれ。今までの苦労を成仏させてくれ。
僕は2021年の年末からHonoというOSSを作っている。それは驚くほど人気になった。2025年8月現在、GitHubのスター数は「26K」。日本人発のプロダクトだと世界で第3位の数字である。この規模のOSSを開発・メンテナンスをできるのは非常に貴重な経験で「僕にしか見れない景色」を見ている。今回はその景色を少しでもあなたに見てもらいたい。決して、OSSにコントリビュートすることを促すわけではない。ただ、あなたが使っているソフトウェアの背景にはとんでもないドラマがあるってことを知ってもらいたい。
具体的には以下のトピックを話します。

Honoの現状
僕らはCPANで息を吸うようにOSSをしていた
GitHubのInboxが恐怖
ありがたいIssueと厄介なIssue
Whyを聞かれると辛い
Share a minimal project to reproduce it!
中学生コントリビューター
登山をしてたら向かいから集団が来て全員に挨拶しなくてはいけない問題
嫉妬される
Noを言うのは大変
やりたいことをシェアしない
Hono Conference
外向的性格がOSSをやると
You are a legend!
頑張ればなんとかなる
そして、希望

まぁ、大変だけどすごく楽しいよ！
同タイトルのプロポーザルをYAPC::Hakodate 2024の際に出しましたが、個人的都合で当日行けなくなりました。テーマは同じですが、当時とは状況が変わっているのでアップデートした内容になります。</abstract>
        <date>2025-11-15T09:30:00%:z</date>
        <start>09:30</start>
        <duration>00:40:00</duration>
        <slug>72e1ace7-5a57-45fe-8d16-3af47539574f</slug>
        <url>https://fortee.jp/yapc-fukuoka-2025/proposal/72e1ace7-5a57-45fe-8d16-3af47539574f</url>
        <persons>
          <person> Yusuke Wada yusukebe </person>
        </persons>
      </event>
      <event id="25">
        <title>JavaScript🦏はPerl🐪の子孫である</title>
        <abstract>本当です。そしてこの事は、2025年現代のプログラミング環境において意外で根強い影響をあちこちに及ぼしています。本Talkではその証拠を提示した上で、なぜそうだったのか、その結果どうなったかを論じます。

証拠 - Proof

語彙 - Vocaburary
"use strict";

理由 - Reason

Y'all can pop it.  but can you shift it?

影響 - Consequence

typeof null === "object"
"🐫".length !== ["🐫"].length

結論 - Conclusion

Why Javascript matters -- and Perl doesn't (so much)
It sucks? Then why are you suckin' it?
Q&amp;A

</abstract>
        <date>2025-11-15T11:30:00%:z</date>
        <start>11:30</start>
        <duration>00:20:00</duration>
        <slug>f5f9114d-14e5-47af-8337-cb637605edd2</slug>
        <url>https://fortee.jp/yapc-fukuoka-2025/proposal/f5f9114d-14e5-47af-8337-cb637605edd2</url>
        <persons>
          <person> Dan Kogai dankogai </person>
        </persons>
      </event>
      <event id="26">
        <title>読む技術・書く技術・伝える技術 - オープンソース活動から学んだ知識循環の実践</title>
        <abstract>JSer.info・textlint・jsprimerというプロジェクトを通じて、私は「書くことは読むことである」という理解に辿り着きました。
この発表では、興味本位で始めた日々の情報収集がツール開発を経て大規模プロジェクトの設計技術へ発展するプロセス、
読む→書く→伝えるの段階的変化についてお話しします。
まず「読む技術」として、JavaScriptの情報サイトである JSer.info （14年間で750記事）の更新を支える情報収集システムを紹介します。

参考: https://jser.info/2021/01/16/jser-10th/

次に「書く技術」として、読むだけでは物足りず「書いてみよう」と思った経験から始ったPromise本執筆時の表記揺れ問題をきっかけに作った、textlintについて紹介します。
書くことで増える読む量や、AI時代における文章品質の自動化の進化についても、textlintのMCP対応のデモも交えて紹介します。

参考: https://efcl.info/2022/06/29/why-create-textlint/

最後に「伝える技術」として、jsprimer という JavaScript 入門書を継続開発する際の文章設計について紹介します。
Design Doc による文章の設計、Living Standard アプローチ、既知→未知の原則、書きやすさより読みやすさを優先する設計思想などを扱います。
また、オープンソースとして100人以上がコントリビューターと参加してもらった仕組みやGitHub Sponsors/Open Collectiveによる経済も触れます。

参考: https://efcl.info/2025/05/24/tskaigi-2025-jsprimer/
</abstract>
        <date>2025-11-15T13:15:00%:z</date>
        <start>13:15</start>
        <duration>00:40:00</duration>
        <slug>64dbeabc-a630-4564-97ff-812106e7be81</slug>
        <url>https://fortee.jp/yapc-fukuoka-2025/proposal/64dbeabc-a630-4564-97ff-812106e7be81</url>
        <persons>
          <person> azu azu_re </person>
        </persons>
      </event>
    </room>
    <room name="Track C">
      <event id="27">
        <title>旧から新へ: 大規模ウェブクローラのPerlからGoへの置き換え</title>
        <abstract>はてなアンテナは登録したURLの更新情報を定期的に取得し、更新内容をまとめるウェブサイト巡回サービスです。
サービス開始以来20年を越えたはてなアンテナでは、Perlで書かれたコードベースの置き換えを進めています。
最初の一手として、数百万件のページを効率よく巡回するクローラをGoで書き直しました。クローラをゼロからつくる中でおこなった実装の選択や、既存のクローラからの移行および運用、既存のバックエンドとのコミュニケーションなど、プロダクトを漸進的に新しくしている過程についてお話しします。
以下のような内容について話す予定です。

モチベーション: PerlからGoへ
実装編

ストレージの選定
キューの実装
producer-consumer パターン
http.Transport

運用編

カナリアリリースと移行戦略
ローカル開発
テスト
旧バックエンドとのコミュニケーション
中間証明書の問題
健全性の監視

</abstract>
        <date>2025-11-15T09:30:00%:z</date>
        <start>09:30</start>
        <duration>00:40:00</duration>
        <slug>f73df5fa-179c-4fb3-80a8-5ba78f5a6832</slug>
        <url>https://fortee.jp/yapc-fukuoka-2025/proposal/f73df5fa-179c-4fb3-80a8-5ba78f5a6832</url>
        <persons>
          <person> motemen motemen </person>
        </persons>
      </event>
      <event id="28">
        <title>Perl の生きのこり</title>
        <abstract>このトークでは、技術の変遷とともにどのようにPerlが変化してきたのか歴史を探求しながら、最近のモダンなPerlを紹介していきます。
Perlを使っている人、かつて使っていた人、プログラミングに興味がある人、プログラミングの歴史に興味がある人など
そんな人たちに「懐かしい〜」「へ〜」と思ってもらえるような内容を、わいとんとkobakenの2人でお送りします。
1990年から2025年現在までのWeb開発を「インターネット掲示板（BBS）」を題材に駆け上がり、各時代の変化のキッカケや背景に触れていきます。
お品書きは次の通りです。

CGI
PSGI/Plack
複雑化するプロダクトにPerlはどう立ち向かってる？
外圧による変化
未来はどうなるか


このトークは「エンジニアがこの先生きのこるためのカンファレンス」 の前夜祭企画をベースに、
YAPC::Fukuoka 2025 用に再編・改善した内容になります。</abstract>
        <date>2025-11-15T10:30:00%:z</date>
        <start>10:30</start>
        <duration>00:40:00</duration>
        <slug>f5ceeb49-9dba-4d7e-84df-f2e312001946</slug>
        <url>https://fortee.jp/yapc-fukuoka-2025/proposal/f5ceeb49-9dba-4d7e-84df-f2e312001946</url>
        <persons>
          <person> わいとん &amp; kobaken </person>
        </persons>
      </event>
      <event id="29">
        <title>エンジニア→人事への『急』な転身で見えた、お互いの誤解と理解</title>
        <abstract>35歳になる目前、私はそれまで当たり前のように身を置いていたプロダクト開発の現場から離れ、人事担当として急転身しました。
エンジニアにとって、近いようで遠い存在である人事。果たして、お互いのことをどれくらい理解しているのでしょうか？
エンジニアから見た人事、人事から見たエンジニア。両方を経験したからこそ分かる、お互いの誤解と理解。人事の日常業務のリアル、エンジニア組織への貢献の仕方、そして技術者と人事の間に橋を架ける意味について、転身してからの4年間の体験をもとにお話しします。
アウトライン

「コードを書かない」決断と「急」転身の理由

EMキャリアから「またコードを書く？」に対する違和感
技術者アイデンティティ・クライシス

両方やったからこそ見えた世界

エンジニア時代に持っていた人事への誤解

「人事って面接だけやってるんでしょ？」
「技術のことなんて分からないでしょ？」


人事になって分かった人事の世界

実際の日常業務とその深さ
組織課題解決への真剣な取り組み
HR業界のプロフェッショナリズムとは

技術者出身だからできること

エンジニアとの信頼関係構築
技術組織の課題理解と解決への貢献
両方の言葉で話せることの価値

4年経った今の率直な感想と学び

コミュニティとの新しい関わり方
「技術者 vs 人事」ではなく「技術者 &amp; 人事」という視点

橋を架ける意味

技術者のキャリアパスの多様性
組織をより良くするための協働の可能性


聴衆が得られるアウトカム

人事という職種への理解
キャリアチェンジの現実的な体験談
技術者と人事の協働の可能性
</abstract>
        <date>2025-11-15T11:30:00%:z</date>
        <start>11:30</start>
        <duration>00:20:00</duration>
        <slug>05b25a83-88ac-4118-ae58-2acd2f0773b0</slug>
        <url>https://fortee.jp/yapc-fukuoka-2025/proposal/05b25a83-88ac-4118-ae58-2acd2f0773b0</url>
        <persons>
          <person> serima serima </person>
        </persons>
      </event>
      <event id="30">
        <title>転ばぬ先のXS入門</title>
        <abstract>普段から業務でPerlのWebアプリケーションを開発・運用している方であっても「cpanfileに ::XS とついたモジュールがいくつか並んでいるところまではわかっているが、難解そうで、実装を追ったりするのはなんとなく避けてしまっている」というような方は少なくないのではないでしょうか (かくいう私もそのような時期がありました……)。
そんなXS、Perlにおけるネイティブ拡張のための仕組みは、

データベースクライアントなど既存のCライブラリへのラッパー

（libmysqlclientに対応するDBD::mysqlや、ImageMagickに対応するPerlMagickなど）

ネイティブコードによる最適化がウリのライブラリ

（JSON::XS、Type::Tiny::XS、……）


など、Webアプリケーション開発において必須とも言えるモジュール群で使われている技術です。一方で、とっつきにくく思われている節があり、なかなか手ほどきを受ける機会もないように思います。
本セッションでは、普段Perlを読み書きしているがXSにはあまり触れたことがない方を主な対象に、XSモジュールに対する心理的なハードルを下げ、リファレンスなどを参照しながら既存のライブラリなどの実装を理解したり、トラブルシューティングができるようになることを目指します。また、Perlに馴染みがない方にとっても、スクリプト言語におけるネイティブ拡張の仕組みのケーススタディとして楽しんでいただければと思います。
トーク内容

CPANモジュールを取り巻くツールチェインのおさらい
XS "急"速入門

「XS言語」の基本的な文法・構造から、外部ライブラリの呼び出しなど

XSモジュール探訪

実際のXSモジュールのコード読解

</abstract>
        <date>2025-11-15T13:15:00%:z</date>
        <start>13:15</start>
        <duration>00:40:00</duration>
        <slug>77fc7998-edaf-4e11-9dda-9f5e96cfe8b6</slug>
        <url>https://fortee.jp/yapc-fukuoka-2025/proposal/77fc7998-edaf-4e11-9dda-9f5e96cfe8b6</url>
        <persons>
          <person> polamjag polamjag </person>
        </persons>
      </event>
      <event id="31">
        <title>ステートレスなLLMでステートフルなAI agentを作る</title>
        <abstract>おしゃべりAIサービス Cotomo (https://cotomo.ai/) の開発のために必要な、ステートフルなAI agentを作る技術についてお話します。
「LLM」と「AI agent」の決定的な違いはなんでしょうか。そもそも「AI agent」の定義が人それぞれなので一概には言えませんが、人とコミュニケーションするのが主な仕事であるAI agentに関していえば、それは「状態」があるかどうかというのは一つの決定的な違いです。つまり、LLMは記憶を持たず、AI agentは記憶を持ちます。正確にいうと、記憶を持っているように見せかけています。
本セッションでは、そもそも「LLMがステートレス」とは何かという話から始め、ステートフルなAI agentのミニマムな実装を見せつつ、「AI agentの記憶」というテーマを深掘りします。
それにしても、この「AI agentの記憶」というものは大変厄介で、技術的にはすべての記憶を同時に持つわけにはいきません。そこで何らかの形で「今必要な記憶」だけを差し込みたいわけですが、そのあたりのソフトウェアエンジニアリング的な面白さも紹介できればと思います。</abstract>
        <date>2025-11-15T14:15:00%:z</date>
        <start>14:15</start>
        <duration>00:40:00</duration>
        <slug>911c337f-0985-4b1b-9dac-3553c35e83cd</slug>
        <url>https://fortee.jp/yapc-fukuoka-2025/proposal/911c337f-0985-4b1b-9dac-3553c35e83cd</url>
        <persons>
          <person> 藤吾郎 (gfx) </person>
        </persons>
      </event>
    </room>
    <room name="Track D">
      <event id="32">
        <title>競馬で学ぶ機械学習の基本と実践</title>
        <abstract>最近、大規模言語モデル（LLM）が急速に普及していますが、すべての分野でLLMが万能というわけではありません。例えば、金融やセキュリティといった高い信頼性が求められる業界では、回帰やブースティング系の "古典的な" 機械学習の技術が、今なお第一線で活躍しています。
その理由は、旧来の機械学習では「この取引は不正利用の可能性が80%」といったように確率を使って物事を予測したり、「なぜそのように予測値が出たのか」という理由を人間が理解しやすい形で説明できる点にあります。身近な例では、金融での与信スコアリングやカード決済や送金等の不正利用の検知などの "予測タスク" に機械学習が今でも使われています。
このトークでは、機械学習のユニークなポイントと私が機械学習を好きな理由について、過去に熱中して作っていた "競馬" を題材にお伝えします。勘や経験則、あるいは人間が地道に作るルールだけでなく、機械学習という道具を手に入れると、競馬の収支を改善するためにどのようなアプローチが可能になるのか？ 最近話題のLLMに尋ねるのとは、何が違うのか？私の過去の実践経験を元に、詳しく説明します。
機械学習について初めて知る人でも楽しめるよう、以下の流れでお話しする予定です。

機械学習の基本

機械学習とは何か？特に教師あり学習について
機械学習が使われている分野
機械学習の利点と欠点
機械学習のシステム構築の流れ
最近の機械学習の潮流

競馬と機械学習

競馬の簡単な紹介
競馬に適した機械学習手法の紹介

競馬の勝ち馬予測モデルの作り方

予測の元になるデータを集める
予測の精度を高めるための特徴量エンジニアリング
予測モデルの構築方法と評価手法

勝ち馬予測モデルの実践

予測値の活用方法
実戦での評価検証

</abstract>
        <date>2025-11-15T10:30:00%:z</date>
        <start>10:30</start>
        <duration>00:40:00</duration>
        <slug>4dd02c14-92fc-4fd2-b93f-5b38463ec32a</slug>
        <url>https://fortee.jp/yapc-fukuoka-2025/proposal/4dd02c14-92fc-4fd2-b93f-5b38463ec32a</url>
        <persons>
          <person> 三谷 昌平 shohei1913 </person>
        </persons>
      </event>
      <event id="33">
        <title>機密情報の漏洩を防げ！ Webフロントエンド開発で意識すべき漏洩ポイントとその対策</title>
        <abstract>Web サイトの JavaScript や CSS はブラウザから閲覧できます。従ってそれらに機密情報が入らないよう、細心の注意を払わなければなりません。なになに? 「minify してるから大丈夫。」「モダンなフレームワーク使ってるから大丈夫。」...だって? 本当にそうですか?
機密情報の漏洩を招くポイントは、様々な場所に潜んでいます。このトークでは、一般的なWebフロントエンド開発で意識すべき漏洩ポイント、そしてその対策についてお話します。

Source Map 経由での漏洩
Client Component 経由での漏洩
Next.js Pages Router の _buildManifest.json
その他注意すべき漏洩ポイント
漏洩の確認方法
漏洩を防ぐには
</abstract>
        <date>2025-11-15T11:30:00%:z</date>
        <start>11:30</start>
        <duration>00:20:00</duration>
        <slug>c705086e-8849-4419-8dce-423f82f41327</slug>
        <url>https://fortee.jp/yapc-fukuoka-2025/proposal/c705086e-8849-4419-8dce-423f82f41327</url>
        <persons>
          <person> mizdra mizdra </person>
        </persons>
      </event>
      <event id="34">
        <title>Crossplaneで築く プラットフォームエンジニアリング ─ 基盤を支えるリソース抽象化のアプローチ</title>
        <abstract>クラウドの利用が広がる中で、複数のプロダクトを横断して安定したインフラ基盤を提供することは、プラットフォームエンジニアリングにおける大きな課題です。
我々の組織hacomonoでは、1,000万人以上の登録ユーザーを抱えるサービスを提供しており、今後はさらに複数のプロダクト展開を計画しています。
これまでプロジェクトごとにAWSアカウントを発行し個別にリソースを管理してきましたが、組織の成長とともに、このやり方だけではスケールしていくのが難しいと考えています。
そこで現在、共通基盤をKubernetes上に構築する取り組みを進めており、その一つの施策として導入しているのが Crossplane です。
CrossplaneとはAWSやGCPなどのパブリッククラウドやKubernetesリソースなどをKubernetesの抽象で管理可能にするOSSのツールです。
Crossplaneによるリソースの抽象化は、開発者がより楽かつ安全にインフラを扱えるようにし、同時に基盤側も裏で進化を続けられる柔軟さをもたらします。
一方で、トラブルシューティング時の原因特定の難しさや、従来のIaCツールとは異なる運用フローへの適応、チーム全体での新たな技術スタックに関する知識共有などの課題も少しずつ見えてきています。
本セッションでは、Crossplaneの概要と、取り組みを通じて見えてきた可能性と難しさ、そして今後の展望を共有します。プラットフォームエンジニアや、Crossplaneの導入を検討している方にとって、参考になる話を届けられればと思います。</abstract>
        <date>2025-11-15T13:15:00%:z</date>
        <start>13:15</start>
        <duration>00:40:00</duration>
        <slug>0182eef3-8c7d-4b80-b6f9-d396b1351d54</slug>
        <url>https://fortee.jp/yapc-fukuoka-2025/proposal/0182eef3-8c7d-4b80-b6f9-d396b1351d54</url>
        <persons>
          <person> 有働開 PbwBi </person>
        </persons>
      </event>
      <event id="35">
        <title>やり方は一つだけじゃない、正解だけを目指さず寄り道やその先まで自分流に楽しむ趣味プログラミングの探求</title>
        <abstract>タイパや効率が最優先されがちな現代ですが、あえて正解までの最短コースだけを目指さず、道のりそのものを味わうプログラミングの楽しみ方を探求し、共有します。
題材の一つとして、毎年12月に小さなパズル問題が毎日出題される「Advent of Code」を紹介します。同じ問題に対しても解法は無数にあり、用いるプログラミング言語もアルゴリズムも様々、まさにTMTOWTDI！ 素朴にコードを書いて正解を導出して終わりにするのではなく、美しく効率的なコードを目指してみたり、業務では絶対に書かないような難解で突飛なものを考えたり、色々な楽しみ方があります。正解とは関係なくパズル入力の可視化に注力している参加者もいて、他の人の取り組みを見るだけでも学びがあり、とても面白く刺激的です。
また、私は個人の趣味活動としても「Pentomino」や「だんご屋のひまつぶし」といったパズルを自ら題材として取り上げ、プログラムで解く取り組みをしてきました。効率的な解法を調査し検証し、また得られた解をWebブラウザ上でインタラクティブに可視化するなど、自分なりのこだわりを持ったやり方で楽しみました。正解だけを求めて一直線で終わらせないからこそ得られた経験や学びを紹介します。
「コードはAIに書かせるもの」になりつつある現在ですが、やっぱり自分でコードを書くのは楽しいものです。自分流のプログラミングの楽しみ方を広げるためのヒントを持ち帰っていただき、“自分も何かやってみよう”という最初の一歩を後押ししたいと思います。</abstract>
        <date>2025-11-15T14:15:00%:z</date>
        <start>14:15</start>
        <duration>00:40:00</duration>
        <slug>5b6d3e99-45db-4c87-a369-f1b78a30e327</slug>
        <url>https://fortee.jp/yapc-fukuoka-2025/proposal/5b6d3e99-45db-4c87-a369-f1b78a30e327</url>
        <persons>
          <person> すぎゃーん sugyan </person>
        </persons>
      </event>
    </room>
  </day>
</schedule>
